<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Private Audio Call / Личный аудиозвонок</title>
  <style>
    #call {
      font-size: 2.5rem;
      padding: 20px 40px;
      border-radius: 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h2>Private Audio Call / Личный аудиозвонок</h2>
  <p id="status">Waiting... / Ожидание...</p>
  <button id="call">Start Call / Начать звонок</button>
  <audio id="remote" autoplay playsinline></audio>

<script>
const SIGNAL_URL = "wss://chat-2u5f.onrender.com/";

// Bilingual text dictionary
const TEXT = {
  waiting:          { en: "Waiting...", ru: "Ожидание..." },
  connecting:       { en: "Connecting WebSocket...", ru: "Подключение WebSocket..." },
  wsConnected:      { en: "Connected. Waiting for peer...", ru: "Подключено. Ожидание собеседника..." },
  wsError:          { en: "WebSocket error. See console.", ru: "Ошибка WebSocket. Смотрите консоль." },
  disconnected:     { en: "Disconnected. Refresh to reconnect.", ru: "Отключено. Обновите страницу для повторного подключения." },
  micDenied:        { en: "Microphone access denied.", ru: "Доступ к микрофону запрещен." },
  peerConnected:    { en: "Peer connected. Starting call...", ru: "Собеседник подключен. Начало звонка..." }
};

// Translate WebRTC connection states
const CONNECTION_TEXT = {
  new:          { en: "New", ru: "Новое" },
  checking:     { en: "Checking", ru: "Проверка..." },
  connected:    { en: "Connected", ru: "Подключено" },
  disconnected: { en: "Disconnected", ru: "Отключено" },
  failed:       { en: "Failed", ru: "Не удалось" },
  closed:       { en: "Closed", ru: "Закрыто" }
};

let ws = null;
let pc = null;
let isInitiator = false;
let roleKnown = false;
let readyToCall = false;
let pendingIce = [];

const statusEl = document.getElementById("status");
const callBtn = document.getElementById("call");
const remoteAudio = document.getElementById("remote");

// Set current language to show both
function setStatus(key) {
  const t = TEXT[key];
  if (t) statusEl.textContent = `${t.en} / ${t.ru}`;
}

// Initial status
setStatus('waiting');

callBtn.onclick = async () => {
  if (ws) return;
  callBtn.disabled = true;
  setStatus('connecting');

  // Request microphone first
  let localStream;
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  } catch (err) {
    console.error(err);
    setStatus('micDenied');
    callBtn.disabled = false;
    return;
  }

  remoteAudio.muted = true;

  ws = new WebSocket(SIGNAL_URL);

  ws.onopen = () => setStatus('wsConnected');

  ws.onmessage = async e => {
    const data = typeof e.data === "string" ? e.data : await e.data.text();
    const msg = JSON.parse(data);

    switch (msg.type) {
      case "role":
        isInitiator = msg.initiator;
        roleKnown = true;
        break;

      case "peers":
        if (msg.count === 2 && roleKnown && !readyToCall) {
          readyToCall = true;
          setStatus('peerConnected');
          await startWebRTC(localStream);
        }
        break;

      case "sdp":
        await handleSDP(msg.sdp);
        break;

      case "ice":
        await handleICE(msg.ice);
        break;
    }
  };

  ws.onerror = () => setStatus('wsError');
  ws.onclose = () => {
    setStatus('disconnected');
    ws = null;
    callBtn.disabled = false;
  };
};

// WebRTC functions
async function startWebRTC(localStream) {
  pc = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  });

  // Add local audio tracks
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  // Remote track
  pc.ontrack = e => {
    remoteAudio.srcObject = e.streams[0];
    remoteAudio.muted = false;
    remoteAudio.play().catch(()=>{});
  };

  // ICE candidates
  pc.onicecandidate = e => {
    if (e.candidate) ws.send(JSON.stringify({ type: "ice", ice: e.candidate }));
  };

  // Connection state changes (translated)
  pc.onconnectionstatechange = () => {
      // Look up translated text
      const t = CONNECTION_TEXT[pc.connectionState] || { en: pc.connectionState, ru: pc.connectionState };
      // Update status
      statusEl.textContent = `Connection: ${t.en} / Подключение: ${t.ru}`;
  };

  if (isInitiator) {
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    ws.send(JSON.stringify({ type: "sdp", sdp: pc.localDescription }));
  }
}

async function handleSDP(sdp) {
  if (!pc) return;
  try {
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    for (const c of pendingIce) await pc.addIceCandidate(c);
    pendingIce = [];
    if (sdp.type === "offer") {
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({ type: "sdp", sdp: pc.localDescription }));
    }
  } catch (err) { console.error(err); }
}

async function handleICE(candidate) {
  if (!candidate) return;
  try {
    const iceCandidate = new RTCIceCandidate(candidate);
    if (pc && pc.remoteDescription) await pc.addIceCandidate(iceCandidate);
    else pendingIce.push(iceCandidate);
  } catch (err) { console.error(err); }
}
</script>
</body>
</html>
